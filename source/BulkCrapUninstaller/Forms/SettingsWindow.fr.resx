<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="label5.Text" xml:space="preserve">
    <value>Ligne de commande avant le début de désinstallation</value>
  </data>
  <data name="label6.Text" xml:space="preserve">
    <value>Ligne de commande après la fin de désinstallation</value>
  </data>
  <data name="checkBoxUpdateSearch.Text" xml:space="preserve">
    <value>Chercher des mises à jour au démarrage</value>
  </data>
  <data name="checkBoxSendStats.Text" xml:space="preserve">
    <value>Envoyer des statistiques anonymes d'utilisation</value>
  </data>
  <data name="label9.Text" xml:space="preserve">
    <value>Langage de l'application :</value>
  </data>
  <data name="label10.Text" xml:space="preserve">
    <value>L'application devra être relancée pour prendre en compte le changement de langage.</value>
  </data>
  <data name="groupBoxMisc.Text" xml:space="preserve">
    <value>Divers</value>
  </data>
  <data name="checkBoxLoud.Text" xml:space="preserve">
    <value>Demander pour supprimer les désinstalleurs causants
d'une tâche silencieuse</value>
  </data>
  <data name="checkBoxBackup.Text" xml:space="preserve">
    <value>Demander pour créer une sauvegarde de registre 
avant la suppression des vestiges</value>
  </data>
  <data name="label1.Text" xml:space="preserve">
    <value>Rechercher des résidus après désinstallation</value>
  </data>
  <data name="label2.Text" xml:space="preserve">
    <value>Créer un point de restauration avant de désinstaller</value>
  </data>
  <data name="groupBoxMessages.Text" xml:space="preserve">
    <value>Boîtes de message</value>
  </data>
  <data name="checkBoxEnableExternal.Text" xml:space="preserve">
    <value>Activer l'exécution d'applications externes</value>
  </data>
  <data name="label7.Text" xml:space="preserve">
    <value>Vous pouvez spécifier des commandes qui se lanceront avant et après la désinstallation. Une ligne égale une commande et sera exécutée comme en utilisant le dialogue "Exécuter...".

BCU attendra la fin de la commande courante avant d'exécuter la suivante.</value>
  </data>
  <data name="groupBoxExternal.Text" xml:space="preserve">
    <value>Applications externes</value>
  </data>
  <data name="button2.Text" xml:space="preserve">
    <value>&amp;Fermer</value>
  </data>
  <data name="tabPageGeneral.Text" xml:space="preserve">
    <value>Général</value>
  </data>
  <data name="tabPageExternal.Text" xml:space="preserve">
    <value>Outils externes</value>
  </data>
  <data name="tabPageMisc.Text" xml:space="preserve">
    <value>Divers</value>
  </data>
  <data name="$this.Text" xml:space="preserve">
    <value>Réglages de BCUninstaller</value>
  </data>
  <data name="tabPageFolders.Text" xml:space="preserve">
    <value>Dossiers</value>
  </data>
  <data name="labelProgramFolders.Text" xml:space="preserve">
    <value>Vous pouvez spécifier des dossiers personnalisés dans lesquels vous installez vos applications (par ex. D:\Applications). Ces dossiers seront utilisés par BCU pour chercher des vestiges de désinstallation, des applications non enregistrées et quelques autres choses. Bien que ce ne soit pas nécessaire, une liste de ces dossiers fera mieux fonctionner BCU.

Les dossiers Windows par défaut sont toujours scannés, vous n'avez pas besoin de les inclure dans la liste.

Utilisez des chemins complets de dossiers, un chemin par ligne. Les chemins invalides et les dossiers non-existants seront ignorés.</value>
  </data>
  <data name="groupBoxProgramFolders.Text" xml:space="preserve">
    <value>Dossiers d'installation des programmes</value>
  </data>
  <data name="checkBoxAutoLoad.Text" xml:space="preserve">
    <value>Charger automatiquement la liste de désinstalleurs "Default.bcul" au démarrage</value>
  </data>
  <data name="checkBoxRatings.Text" xml:space="preserve">
    <value>Activer les notes utilisateurs des applications</value>
  </data>
  <data name="tabPage1.Text" xml:space="preserve">
    <value>Désinstallation</value>
  </data>
  <data name="checkBoxShowAllBadJunk.Text" xml:space="preserve">
    <value>Toujours montrer les résidus avec faible confiance</value>
  </data>
  <data name="checkBoxNeverFeedback.Text" xml:space="preserve">
    <value>Ne jamais demander  mes impressions ou  de l'aide</value>
  </data>
  <data name="checkBoxScanSteam.Text" xml:space="preserve">
    <value>Steam</value>
  </data>
  <data name="checkBoxScanRegistry.Text" xml:space="preserve">
    <value>Registre (il est recommandé de laisser activé) </value>
  </data>
  <data name="checkBoxScanDrives.Text" xml:space="preserve">
    <value>Lecteurs (détecte les apps non enregistrées)</value>
  </data>
  <data name="checkBoxPreDefined.Text" xml:space="preserve">
    <value>Basé sur des règles pré-définies</value>
  </data>
  <data name="groupBox1.Text" xml:space="preserve">
    <value>Chercher des applications dans...</value>
  </data>
  <data name="groupBoxAppStores.Text" xml:space="preserve">
    <value>Magasins d'application à scanner</value>
  </data>
  <data name="tabPageDetection.Text" xml:space="preserve">
    <value>Détection</value>
  </data>
  <data name="checkBoxScanStoreApps.Text" xml:space="preserve">
    <value>Apps du Windows Store</value>
  </data>
  <data name="checkBoxScanWinFeatures.Text" xml:space="preserve">
    <value>Fonctionnalités Windows</value>
  </data>
  <data name="labelWinFeatureInfo.Text" xml:space="preserve">
    <value>La détection des Fonctionnalités Windows utilise WMI et peut être lente et même échouer sur certains systèmes (indiquant d'habitude une corruption du système).</value>
  </data>
  <data name="checkBoxScanWinUpdates.Text" xml:space="preserve">
    <value>Windows Update</value>
  </data>
  <data name="labelWinUpdateInfo.Text" xml:space="preserve">
    <value>La détection de Windows Update utilise WUA, qui est lent. Cela peut prendre quelques minutes.</value>
  </data>
</root>